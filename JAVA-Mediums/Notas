//el encapsulamiento nos permite controlar el acceso
	// alos atributos de nuestra clase
	
	
	//private para evitar acceder directamente
	
	//para poder leer o modificar usaremos get y set
	
	//get obtener valor de un atributo
	
	//set modificar un valor de un atributo
	
	los atributos privados se representan con guiones (-)
	los atributos publicos se representan con cruces (+)
	
	
	Herencia 
	
	Clases padres[metodos](superclase) -> Clases Hijas[metodos_heredados+metodos_propios](subclase)
	
	ejemplo
	Clase Animal:
		Metodos:
			Comer()
			Dormir()
			
			
	Clase Perro:
		Metodos:
			Comer()
			Dormir()
			Raza()
			
	El modificador protected 
	ejemplo:
	Protected class noseWe(){}
	hace que la clase sea inaccesible directamente
	pero si puede acceder a ella por medio de herencia
	esto por medio de sus clases hijas
	
	si no se le pone modificador el atributo de la clase
	o la clase solo se puede acceder en el mismo archivo
	
	un metodo privado no se puede heredar <-----------------------
	
	@Override funciona para aclarar la sobreescritura
	de una clase, es una nota
	
	para sobreescribir una funcion de la clase padre
	en la clase hija solo se escribe exactamente
	la misma funcion en la clase hija y se hacen
	los cambios correspondientes 
	
	usando la palabra clave Super podemos usar los metodos
	de la clase padre que fueron sobreescritos, es como usar
	la version anterior a su sobreescritura
	
	polimorfismo significan diferentes formas
	En herencia si tenemos una funcion padre y varias funciones hijas
	que se van heredando dentro de si, por ejemplo
	Abuelo -> Padre -> Hijo 
	
	en este caso los 3 pueden tener el metodo de Bigote();
	
	Abuelo hereda el metodo Bigote a las clases con menor
	herarquia pero estas mismas la reescriben a su manera
	si mandamos a llamar por ejemplo
	Hijo.bigote(); en este caso la clase que se llamaria
	seria la de menor jerarquia hasta ese punto
	osea SU METODO BIGOTE esto a menos que no haya sobreescritura de ningun
	tipo
	
	el polimorfismo depende de la herencia y la sobreescritura
	ya que puedes tener distintas formas de ejecucion de una misma funcion
	por ejemplo Abuelo heredo a Padre, padre lo sobreescribio y lo que hereda
	la clase hijo tambien se sobreescribe 
	por lo tanto tienes un mismo metodo definido en 3 clases diferentes
	con 3 formas diferentes del metodo, pero que a su vez las 2 posteriores parten 
	de una sola.
	
	por lo tanto se veria algo asi 
	
	Abuelo.Bigote();  
	Padre.Bigote()*;
	Hijo.Bigote()**;
	
	esto puede variar mucho por ejemplo
	no habria polimorfismo si desde la clase abuelo
	se heredara la misma funcion sin cambios
	solo seria una funcion accesible para distintos tipos 
	de objetos
	
	EN HERENCIAS NO PODEMOS DEJAR DEFAULT O PRIVATE
	
	Jerarquia de modificadores 
	en terminos de prohibiciones:
	Private -1
	Default -2
	Protected -3
	Public -4
	
	un metodo polimorfico es aquel metodo
	que como parametro recibe datos de la 
	clase padre y por lo tanto de las clases hijas
	
	la clase object es la clase padre de todas las clases
	de java

	la clase object contiene 
	-equals()
	-toString()
	-hashCode()
	
	estos metodos se pueden sobreescribir
	
	con CTRL + 7 puedes comentar
	partes del codigo, si no lo sabia 
	
	
	
	Contexto estatico 
	creacion de clases -> contexto Estatico
	creacion de objetos -> contexto Dinamico
	
	el contexto estatico no puede acceder al contexto
	dinamico ya que apenas estamos definiendo la clase
	por lo tanto no hay objetos
	
	desde el contexto dinamico si se puede acceder al
	contexto estatico 
	
	los atributos estaticos son los que estan relacionados 
	con aspectos de la clase, como valores meta, mientras que los 
	dinamicos seran atributos relacionados a los objetos
	
	
	Las clases abstractas son aquellas que dejan sin implementar alguno de sus
	metodos, para que las clases hijas o derivadas proporcione la implementacion.
	
	eso si las clases hijas para poder ser clases hijas deben ser clases abstractas
	o usar obligatoriamente los metodos abstractos
	
	tampoco puedes instanciarla osea no puedes crear objetos de clases abstractas
	
	Interfaces:
	Una interface es un tipo similar a una clase abstracta. Sin embargo la interface
	se enfoca mas en el comportamiento, y la clase abstracta se enfoca en abstraer 
	caracteristicas en comun
	
	es una relacion entre una clase la cual nos da unas funciones
	las cuales las funciones relacionadas a ella deben implementar
	para cumplir con esa relacion entre clases
	
	los metodos definidos en la interface son abstractos
	y publicos
	
	en este caso como no son clases padres o hijas sino de relacion por 
	mplementacion se escribe ASI
	
	class [nombre de la clase]  implements [Interface]{}
	
	
	Colecciones:
	una coleccion representa un grupo de objetos
	algunas colecciones permiten elementos
	duplicados y otras no, algunas tienen sus
	elementos ordenados y otras no
	
	Collection: List y Set
	List -> Arrayset
	set -> SortedSet
	
	Map -> HashMap
	
	
	JAVABEANS:
	Un JavaBean es una clase de java que debe cubrir
	ciertas caracteristicas:
	
	-Debe tener un constructor vacio aunque puede
	tener mas constructores
	
	-Debe aplicar el concepto de encapsulamiento.
	
	-Debe implemenetar la interface Seralizable.
	permite enviar datos a la red o a discos duros
	
	
	sintaxis de lista:
	List<String> Semana = new ArrayList<String>();
	esto es con tipo de dato especificado 
	
	List miLista = new ArrayList();
	esto es con datos en general de tipo Object (Genericos)
	
	para definir que queremos datos en general de cualquier tipo
	ponemos Object 
	
	Los sets no permiten elementos duplicados